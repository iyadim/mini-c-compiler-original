# Generated by c.py
# Last Author: Iyad Milhem(Spring 2022)

# Original Author: Atul Varma (Spring 2004)

    .text
 # DECLARING  STACK GUARD VALUE CONSTANT FOR THIS PROJECT
 #
    .globl	___stack_chk_guard
    .data
    ___stack_chk_guard:
      .int 0xDEADBEEFu
STACKGUARD0:
 	.ascii "ERROR: __stack_chk_guard has been corrupted"
    .text
 	.globl	___stack_chk_fail
    .def	___stack_chk_fail;	.scl	2;	.type	32;	.endef

  # BEGIN FUNCTION: stack_chk_fail()

___stack_chk_fail:
	pushl	%ebp
    movl	%esp, %ebp
	subl	$24, %esp
	movl	$LC0, (%esp)
	call	_puts
 	nop
    pushl $0                          # Push arg 1
    call _exit                        # Call exit()
    addl $4, %esp                     # Deallocate argument stack
	leave
	ret
# End FUNCTION: stack_chk_fail()

# BEGIN FUNCTION: addition() -------------------------------------------
#
# Function type: function(int,int)->int

    .global _addition
_addition:
  pushl %ebp                        # Save old frame pointer
  movl %esp, %ebp                   # Set new frame pointer
  subl $8, %esp                     # Allocate space for local+temp vars
  leal -4(%ebp), %edx               # Get address of guard
  movl $3735928559, (%edx)          # Perform assignment '='
  movl (%edx), %ecx                 # Copy assignment result to register
  leal -8(%ebp), %ecx               # Get address of sum
  movl 8(%ebp), %edx                # Get value of num1
  movl 12(%ebp), %eax               # Get value of num2
  addl %eax, %edx                   # Perform '+'
  movl %edx, (%ecx)                 # Perform assignment '='
  movl (%ecx), %eax                 # Copy assignment result to register

# Compare stack guard Canary 

  movl -4(%ebp), %eax               # Get canary value from stack
  xorl ___stack_chk_guard, %eax     # Compare %eax canary with original canary
  je .L0_done
  call ___stack_chk_fail            # It is not same canary go to fail function 

  # If the canary is the same there is no buffer overflow and it will go to next step.

.L0_done:
  movl -8(%ebp), %eax               # Get value of sum
  movl %eax, %eax                   # Set return value
  jmp .L0_function_end              # Exit function
.L0_function_end:
  movl %ebp, %esp                   # Deallocate stack frame
  popl %ebp                         # Restore old stack frame
  ret


# END FUNCTION: addition() ---------------------------------------------


# BEGIN FUNCTION: main() -----------------------------------------------
#
# Function type: function()->int

    .global _main
_main:
  pushl %ebp                        # Save old frame pointer
  movl %esp, %ebp                   # Set new frame pointer
  subl $28, %esp                    # Allocate space for local+temp vars
  leal -12(%ebp), %edx              # Get address of guard
  movl $3735928559, (%edx)          # Perform assignment '='
  movl (%edx), %ecx                 # Copy assignment result to register
  leal -8(%ebp), %ecx               # Get address of c2

  # FUNCTION CALL to addition() - begin

  movl %ecx, -24(%ebp)              # Save caller-save register to temp
  pushl $1                          # Push arg 2
  pushl $1                          # Push arg 1
  call _addition                    # Call addition()
  addl $8, %esp                     # Deallocate argument stack

  # FUNCTION CALL to addition() - end

  movl -24(%ebp), %ecx              # Stack machine: copy temp to register
  movl %eax, (%ecx)                 # Perform assignment '='
  movl (%ecx), %edx                 # Copy assignment result to register

  # FUNCTION CALL to printf() - begin

  movl -8(%ebp), %edx               # Get value of c2
  pushl %edx                        # Push arg 2
  movl $LC0, %edx                   # Get addr of string literal 'additio...'
  pushl %edx                        # Push arg 1
  call _printf                      # Call printf()
  addl $8, %esp                     # Deallocate argument stack

  # FUNCTION CALL to printf() - end

  leal -4(%ebp), %eax               # Get address of a
  movl $0, (%eax)                   # Perform assignment '='
  movl (%eax), %edx                 # Copy assignment result to register

  # FUNCTION CALL to printf() - begin

  movl $LC1, %edx                   # Get addr of string literal 'Please ...'
  pushl %edx                        # Push arg 1
  call _printf                      # Call printf()
  addl $4, %esp                     # Deallocate argument stack

  # FUNCTION CALL to printf() - end

  leal -20(%ebp), %eax              # Get address of n

  # FUNCTION CALL to read() - begin

  movl %eax, -28(%ebp)              # Save caller-save register to temp
  pushl $35                         # Push arg 3
  leal -13(%ebp), %eax              # Get address of c1
                                    # (Address-of operator '&' used here)
  pushl %eax                        # Push arg 2
  pushl $0                          # Push arg 1
  call _read                        # Call read()
  addl $12, %esp                    # Deallocate argument stack

  # FUNCTION CALL to read() - end

  movl -28(%ebp), %edx              # Stack machine: copy temp to register
  movl %eax, (%edx)                 # Perform assignment '='
  movl (%edx), %ecx                 # Copy assignment result to register

  # IF statment - begin

  movl -4(%ebp), %ecx               # Get value of a
  cmpl $0, %ecx                     # Compare %ecx to $0
  sete %cl                          # Perform '=='
  movzbl %cl, %ecx                  # Zero-extend the boolean result
  testl %ecx, %ecx                  # Test the result
  jz .L3_else                       # If result is zero, jump to else clause

  # IF statment - THEN clause - begin


  # FUNCTION CALL to printf() - begin

  movl $LC2, %ecx                   # Get addr of string literal 'a has N...'
  pushl %ecx                        # Push arg 1
  call _printf                      # Call printf()
  addl $4, %esp                     # Deallocate argument stack

  # FUNCTION CALL to printf() - end


  # IF statment - THEN clause - end

  jmp .L2_done

  # IF statment - ELSE clause - begin

.L3_else:

  # FUNCTION CALL to printf() - begin

  movl $LC3, %eax                   # Get addr of string literal 'a has c...'
  pushl %eax                        # Push arg 1
  call _printf                      # Call printf()
  addl $4, %esp                     # Deallocate argument stack

  # FUNCTION CALL to printf() - end


  # IF statment - ELSE clause - end

.L2_done:

  # IF statment - end


  # FUNCTION CALL to printf() - begin

  movl $LC4, %eax                   # Get addr of string literal 'Exiting...'
  pushl %eax                        # Push arg 1
  call _printf                      # Call printf()
  addl $4, %esp                     # Deallocate argument stack

  # FUNCTION CALL to printf() - end


# Compare stack guard Canary 

  movl -4(%ebp), %eax               # Get canary value from stack
  xorl ___stack_chk_guard, %eax     # Compare %eax canary with original canary
  je .L1_done
  call ___stack_chk_fail            # It is not same canary go to fail function 

  # If the canary is the same there is no buffer overflow and it will go to next step.

.L1_done:
  movl $0, %eax                     # Set return value
  jmp .L1_function_end              # Exit function
.L1_function_end:
  movl %ebp, %esp                   # Deallocate stack frame
  popl %ebp                         # Restore old stack frame
  ret


# END FUNCTION: main() -------------------------------------------------

.global_vars:

LC0:
  .ascii "addition result %i: \12\0"
LC1:
  .ascii "Please give input: \12\0"
LC2:
  .ascii "a has NOT changed.\12\0"
LC3:
  .ascii "a has changed. Buffer Overflow!\12\0"
LC4:
  .ascii "Exiting\12\0"

